using Dapper;
using Npgsql;
using Rgt.Space.Core.Abstractions.Identity;
using Rgt.Space.Core.Abstractions.Tenancy;
using Rgt.Space.Core.Domain.Entities.Identity;

namespace Rgt.Space.Infrastructure.Persistence.Dac.Identity;

public sealed class UserWriteDac : IUserWriteDac
{
    private readonly ITenantConnectionFactory _connFactory;

    public UserWriteDac(ITenantConnectionFactory connFactory)
    {
        _connFactory = connFactory;
    }

    public async Task<Guid> CreateAsync(User user, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        // Note: ID is generated by DB default (uuid_generate_v7()) if we pass NULL, 
        // but User entity might already have a Guid if created via factory.
        // We'll use the Entity's ID if present, or let DB generate if empty.
        // Actually, User.CreateFromSso uses Guid.NewGuid().
        // So we insert it.

        const string sql = @"
            INSERT INTO users (
                id, display_name, email, contact_number, is_active,
                local_login_enabled, password_hash, password_salt,
                sso_login_enabled, sso_provider, external_id, sso_email,
                created_at, created_by, updated_at, updated_by
            ) VALUES (
                @Id, @DisplayName, @Email, @ContactNumber, @IsActive,
                @LocalLoginEnabled, @PasswordHash, @PasswordSalt,
                @SsoLoginEnabled, @SsoProvider, @ExternalId, @SsoEmail,
                @CreatedAt, @CreatedBy, @UpdatedAt, @UpdatedBy
            ) RETURNING id;";

        // Map Entity properties to params
        var p = new
        {
            user.Id,
            user.DisplayName,
            user.Email,
            user.ContactNumber,
            user.IsActive,
            user.LocalLoginEnabled,
            user.PasswordHash,
            user.PasswordSalt,
            user.SsoLoginEnabled,
            user.SsoProvider,
            user.ExternalId,
            user.SsoEmail,
            user.CreatedAt,
            user.CreatedBy,
            user.UpdatedAt,
            user.UpdatedBy
        };

        return await conn.ExecuteScalarAsync<Guid>(sql, p);
    }

    public async Task UpdateAsync(User user, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            UPDATE users SET
                display_name = @DisplayName,
                email = @Email,
                contact_number = @ContactNumber,
                is_active = @IsActive,
                sso_login_enabled = @SsoLoginEnabled,
                sso_provider = @SsoProvider,
                external_id = @ExternalId,
                sso_email = @SsoEmail,
                is_deleted = @IsDeleted,
                deleted_at = @DeletedAt,
                deleted_by = @DeletedBy,
                updated_at = @UpdatedAt,
                updated_by = @UpdatedBy
            WHERE id = @Id;";

        await conn.ExecuteAsync(sql, new
        {
            user.Id,
            user.DisplayName,
            user.Email,
            user.ContactNumber,
            user.IsActive,
            user.SsoLoginEnabled,
            user.SsoProvider,
            user.ExternalId,
            user.SsoEmail,
            user.IsDeleted,
            user.DeletedAt,
            user.DeletedBy,
            user.UpdatedAt,
            user.UpdatedBy
        });
    }

    public async Task UpdateLastLoginAsync(Guid userId, string provider, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            UPDATE users SET
                last_login_at = @Now,
                last_login_provider = @Provider
            WHERE id = @Id;";

        await conn.ExecuteAsync(sql, new
        {
            Id = userId,
            Provider = provider,
            Now = DateTime.UtcNow
        });
    }

    public async Task<User?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            SELECT 
                id, display_name, email, contact_number, is_active,
                local_login_enabled, password_hash, password_salt,
                password_expiry_at, password_reset_token, password_reset_expires_at,
                sso_login_enabled, sso_provider, external_id, sso_email,
                last_login_at, last_login_provider,
                created_at, created_by, updated_at, updated_by,
                is_deleted, deleted_at, deleted_by
            FROM users
            WHERE id = @Id AND is_deleted = FALSE;";

        // We use a custom mapper or Dapper's ability to map to constructor.
        // Since User has a private constructor, Dapper might struggle unless we have a public one or use a custom mapping.
        // However, User.Rehydrate is the factory method.
        // Let's fetch dynamic and use Rehydrate.

        var row = await conn.QuerySingleOrDefaultAsync(sql, new { Id = id });

        if (row == null) return null;

        return User.Rehydrate(
            id: row.id,
            displayName: row.display_name,
            email: row.email,
            contactNumber: row.contact_number,
            isActive: row.is_active,
            localLoginEnabled: row.local_login_enabled,
            passwordHash: row.password_hash,
            passwordSalt: row.password_salt,
            passwordExpiryAt: row.password_expiry_at,
            passwordResetToken: row.password_reset_token,
            passwordResetExpiresAt: row.password_reset_expires_at,
            ssoLoginEnabled: row.sso_login_enabled,
            ssoProvider: row.sso_provider,
            externalId: row.external_id,
            ssoEmail: row.sso_email,
            lastLoginAt: row.last_login_at,
            lastLoginProvider: row.last_login_provider,
            createdAt: row.created_at,
            createdBy: row.created_by,
            updatedAt: row.updated_at,
            updatedBy: row.updated_by,
            isDeleted: row.is_deleted,
            deletedAt: row.deleted_at,
            deletedBy: row.deleted_by
        );
    }

    public async Task<bool> GrantPermissionAsync(Guid userId, string module, string subModule, bool canView, bool canInsert, bool canEdit, bool canDelete, Guid grantedBy, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            WITH target_resource AS (
                SELECT r.id 
                FROM resources r
                JOIN modules m ON r.module_id = m.id
                WHERE m.code = @Module AND r.code = @SubModule
            ),
            target_permissions AS (
                SELECT p.id, a.code
                FROM permissions p
                JOIN actions a ON p.action_id = a.id
                WHERE p.resource_id = (SELECT id FROM target_resource)
            )
            INSERT INTO user_permission_overrides (
                user_id, permission_id, is_allowed, 
                created_at, created_by, updated_at, updated_by
            )
            SELECT 
                @UserId, tp.id, 
                CASE 
                    WHEN tp.code = 'VIEW' THEN @CanView
                    WHEN tp.code = 'INSERT' THEN @CanInsert
                    WHEN tp.code = 'EDIT' THEN @CanEdit
                    WHEN tp.code = 'DELETE' THEN @CanDelete
                END,
                @Now, @GrantedBy, @Now, @GrantedBy
            FROM target_permissions tp
            WHERE tp.code IN ('VIEW', 'INSERT', 'EDIT', 'DELETE')
            ON CONFLICT (user_id, permission_id) DO UPDATE SET
                is_allowed = EXCLUDED.is_allowed,
                updated_at = EXCLUDED.updated_at,
                updated_by = EXCLUDED.updated_by;";

        var rowsAffected = await conn.ExecuteAsync(sql, new
        {
            UserId = userId,
            Module = module,
            SubModule = subModule,
            CanView = canView,
            CanInsert = canInsert,
            CanEdit = canEdit,
            CanDelete = canDelete,
            GrantedBy = grantedBy,
            Now = DateTime.UtcNow
        });

        return rowsAffected > 0;
    }

    public async Task<bool> RevokePermissionAsync(Guid userId, string module, string subModule, Guid revokedBy, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            DELETE FROM user_permission_overrides
            WHERE user_id = @UserId
              AND permission_id IN (
                  SELECT p.id
                  FROM permissions p
                  JOIN resources r ON p.resource_id = r.id
                  JOIN modules m ON r.module_id = m.id
                  WHERE m.code = @Module AND r.code = @SubModule
              );";

        var rowsAffected = await conn.ExecuteAsync(sql, new
        {
            UserId = userId,
            Module = module,
            SubModule = subModule
        });

        return rowsAffected > 0;
    }

    public async Task DeleteAsync(Guid userId, Guid deletedBy, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        const string sql = @"
            UPDATE users 
            SET is_deleted = TRUE, 
                deleted_at = NOW() AT TIME ZONE 'utc', 
                deleted_by = @DeletedBy,
                is_active = FALSE,
                updated_at = NOW() AT TIME ZONE 'utc',
                updated_by = @DeletedBy
            WHERE id = @Id AND is_deleted = FALSE;";

        await conn.ExecuteAsync(sql, new { Id = userId, DeletedBy = deletedBy });
    }

    public async Task<int> DeleteUserAssignmentsAsync(Guid userId, Guid deletedBy, CancellationToken ct = default)
    {
        var connString = await _connFactory.GetSqlConnectionStringAsync(string.Empty, ct);
        await using var conn = new NpgsqlConnection(connString);

        // Soft-delete all project_assignments for this user
        const string sql = @"
            UPDATE project_assignments 
            SET is_deleted = TRUE, 
                deleted_at = NOW() AT TIME ZONE 'utc', 
                deleted_by = @DeletedBy,
                updated_at = NOW() AT TIME ZONE 'utc',
                updated_by = @DeletedBy
            WHERE user_id = @UserId AND is_deleted = FALSE;";

        var rowsAffected = await conn.ExecuteAsync(sql, new { UserId = userId, DeletedBy = deletedBy });
        return rowsAffected;
    }
}
